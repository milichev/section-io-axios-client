/* tslint:disable */
/* eslint-disable */
/**
 * Section API
 * Get edgey with the Section API
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ErrorModel } from '../models';
import { MultiErrorModel } from '../models';
import { ProxyConfiguration } from '../models';
import { RFC6902Operation } from '../models';
/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the proxy's configuration.
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationGet: async (accountId: number, applicationId: number, environmentName: string, proxyName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling configurationGet.');
            }
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling configurationGet.');
            }
            // verify required parameter 'environmentName' is not null or undefined
            if (environmentName === null || environmentName === undefined) {
                throw new RequiredError('environmentName','Required parameter environmentName was null or undefined when calling configurationGet.');
            }
            // verify required parameter 'proxyName' is not null or undefined
            if (proxyName === null || proxyName === undefined) {
                throw new RequiredError('proxyName','Required parameter proxyName was null or undefined when calling configurationGet.');
            }
            const localVarPath = `/account/{accountId}/application/{applicationId}/environment/{environmentName}/proxy/{proxyName}/configuration`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentName"}}`, encodeURIComponent(String(environmentName)))
                .replace(`{${"proxyName"}}`, encodeURIComponent(String(proxyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required

            // authentication keyInQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the proxy's configuration.
         * @param {ProxyConfiguration} body Proxy configuration update details
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationPost: async (body: ProxyConfiguration, accountId: number, applicationId: number, environmentName: string, proxyName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling configurationPost.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling configurationPost.');
            }
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling configurationPost.');
            }
            // verify required parameter 'environmentName' is not null or undefined
            if (environmentName === null || environmentName === undefined) {
                throw new RequiredError('environmentName','Required parameter environmentName was null or undefined when calling configurationPost.');
            }
            // verify required parameter 'proxyName' is not null or undefined
            if (proxyName === null || proxyName === undefined) {
                throw new RequiredError('proxyName','Required parameter proxyName was null or undefined when calling configurationPost.');
            }
            const localVarPath = `/account/{accountId}/application/{applicationId}/environment/{environmentName}/proxy/{proxyName}/configuration`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentName"}}`, encodeURIComponent(String(environmentName)))
                .replace(`{${"proxyName"}}`, encodeURIComponent(String(proxyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required

            // authentication keyInQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch the proxy with a JSON Patch. See - RFC6902 https://tools.ietf.org/html/rfc6902 - http://jsonpatch.com/
         * @param {Array&lt;RFC6902Operation&gt;} body 
         * @param {string} filepath the path to the file you want to modify. Case-sensitive.
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFile: async (body: Array<RFC6902Operation>, filepath: string, accountId: number, applicationId: number, environmentName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchFile.');
            }
            // verify required parameter 'filepath' is not null or undefined
            if (filepath === null || filepath === undefined) {
                throw new RequiredError('filepath','Required parameter filepath was null or undefined when calling patchFile.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling patchFile.');
            }
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling patchFile.');
            }
            // verify required parameter 'environmentName' is not null or undefined
            if (environmentName === null || environmentName === undefined) {
                throw new RequiredError('environmentName','Required parameter environmentName was null or undefined when calling patchFile.');
            }
            const localVarPath = `/account/{accountId}/application/{applicationId}/environment/{environmentName}/update`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentName"}}`, encodeURIComponent(String(environmentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required

            // authentication keyInQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (filepath !== undefined && filepath !== null) {
                localVarHeaderParameter['filepath'] = String(filepath);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message to a specified proxy
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {string} operationName 
         * @param {string} [operationParameter] Parmeter to send with the message to a proxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proxyOperationAction: async (accountId: number, applicationId: number, environmentName: string, proxyName: string, operationName: string, operationParameter?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling proxyOperationAction.');
            }
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling proxyOperationAction.');
            }
            // verify required parameter 'environmentName' is not null or undefined
            if (environmentName === null || environmentName === undefined) {
                throw new RequiredError('environmentName','Required parameter environmentName was null or undefined when calling proxyOperationAction.');
            }
            // verify required parameter 'proxyName' is not null or undefined
            if (proxyName === null || proxyName === undefined) {
                throw new RequiredError('proxyName','Required parameter proxyName was null or undefined when calling proxyOperationAction.');
            }
            // verify required parameter 'operationName' is not null or undefined
            if (operationName === null || operationName === undefined) {
                throw new RequiredError('operationName','Required parameter operationName was null or undefined when calling proxyOperationAction.');
            }
            const localVarPath = `/account/{accountId}/application/{applicationId}/environment/{environmentName}/proxy/{proxyName}/{operationName}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentName"}}`, encodeURIComponent(String(environmentName)))
                .replace(`{${"proxyName"}}`, encodeURIComponent(String(proxyName)))
                .replace(`{${"operationName"}}`, encodeURIComponent(String(operationName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required

            // authentication keyInQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (operationParameter !== undefined) {
                localVarQueryParameter['operationParameter'] = operationParameter;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Applies a varnish ban expression to the specified proxy
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {string} [banExpression] The varnish ban expression to apply
         * @param {boolean} [async] If true the call will return immediately, not waiting for all delivery nodes to complete the ban
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proxyStatePost: async (accountId: number, applicationId: number, environmentName: string, proxyName: string, banExpression?: string, async?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling proxyStatePost.');
            }
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling proxyStatePost.');
            }
            // verify required parameter 'environmentName' is not null or undefined
            if (environmentName === null || environmentName === undefined) {
                throw new RequiredError('environmentName','Required parameter environmentName was null or undefined when calling proxyStatePost.');
            }
            // verify required parameter 'proxyName' is not null or undefined
            if (proxyName === null || proxyName === undefined) {
                throw new RequiredError('proxyName','Required parameter proxyName was null or undefined when calling proxyStatePost.');
            }
            const localVarPath = `/account/{accountId}/application/{applicationId}/environment/{environmentName}/proxy/{proxyName}/state`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"environmentName"}}`, encodeURIComponent(String(environmentName)))
                .replace(`{${"proxyName"}}`, encodeURIComponent(String(proxyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required

            // authentication keyInQuery required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("access_token")
                    : await configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            if (banExpression !== undefined) {
                localVarQueryParameter['banExpression'] = banExpression;
            }

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the proxy's configuration.
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configurationGet(accountId: number, applicationId: number, environmentName: string, proxyName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyConfiguration>> {
            const localVarAxiosArgs = await ProxyApiAxiosParamCreator(configuration).configurationGet(accountId, applicationId, environmentName, proxyName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set the proxy's configuration.
         * @param {ProxyConfiguration} body Proxy configuration update details
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configurationPost(body: ProxyConfiguration, accountId: number, applicationId: number, environmentName: string, proxyName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorModel>> {
            const localVarAxiosArgs = await ProxyApiAxiosParamCreator(configuration).configurationPost(body, accountId, applicationId, environmentName, proxyName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patch the proxy with a JSON Patch. See - RFC6902 https://tools.ietf.org/html/rfc6902 - http://jsonpatch.com/
         * @param {Array&lt;RFC6902Operation&gt;} body 
         * @param {string} filepath the path to the file you want to modify. Case-sensitive.
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFile(body: Array<RFC6902Operation>, filepath: string, accountId: number, applicationId: number, environmentName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ProxyApiAxiosParamCreator(configuration).patchFile(body, filepath, accountId, applicationId, environmentName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send a message to a specified proxy
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {string} operationName 
         * @param {string} [operationParameter] Parmeter to send with the message to a proxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proxyOperationAction(accountId: number, applicationId: number, environmentName: string, proxyName: string, operationName: string, operationParameter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProxyApiAxiosParamCreator(configuration).proxyOperationAction(accountId, applicationId, environmentName, proxyName, operationName, operationParameter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Applies a varnish ban expression to the specified proxy
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {string} [banExpression] The varnish ban expression to apply
         * @param {boolean} [async] If true the call will return immediately, not waiting for all delivery nodes to complete the ban
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proxyStatePost(accountId: number, applicationId: number, environmentName: string, proxyName: string, banExpression?: string, async?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProxyApiAxiosParamCreator(configuration).proxyStatePost(accountId, applicationId, environmentName, proxyName, banExpression, async, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the proxy's configuration.
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationGet(accountId: number, applicationId: number, environmentName: string, proxyName: string, options?: any): AxiosPromise<ProxyConfiguration> {
            return ProxyApiFp(configuration).configurationGet(accountId, applicationId, environmentName, proxyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the proxy's configuration.
         * @param {ProxyConfiguration} body Proxy configuration update details
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configurationPost(body: ProxyConfiguration, accountId: number, applicationId: number, environmentName: string, proxyName: string, options?: any): AxiosPromise<ErrorModel> {
            return ProxyApiFp(configuration).configurationPost(body, accountId, applicationId, environmentName, proxyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch the proxy with a JSON Patch. See - RFC6902 https://tools.ietf.org/html/rfc6902 - http://jsonpatch.com/
         * @param {Array&lt;RFC6902Operation&gt;} body 
         * @param {string} filepath the path to the file you want to modify. Case-sensitive.
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFile(body: Array<RFC6902Operation>, filepath: string, accountId: number, applicationId: number, environmentName: string, options?: any): AxiosPromise<any> {
            return ProxyApiFp(configuration).patchFile(body, filepath, accountId, applicationId, environmentName, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message to a specified proxy
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {string} operationName 
         * @param {string} [operationParameter] Parmeter to send with the message to a proxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proxyOperationAction(accountId: number, applicationId: number, environmentName: string, proxyName: string, operationName: string, operationParameter?: string, options?: any): AxiosPromise<void> {
            return ProxyApiFp(configuration).proxyOperationAction(accountId, applicationId, environmentName, proxyName, operationName, operationParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * Applies a varnish ban expression to the specified proxy
         * @param {number} accountId The account identifier number
         * @param {number} applicationId The application identifier number
         * @param {string} environmentName The name of the environment
         * @param {string} proxyName The proxy identifier
         * @param {string} [banExpression] The varnish ban expression to apply
         * @param {boolean} [async] If true the call will return immediately, not waiting for all delivery nodes to complete the ban
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proxyStatePost(accountId: number, applicationId: number, environmentName: string, proxyName: string, banExpression?: string, async?: boolean, options?: any): AxiosPromise<void> {
            return ProxyApiFp(configuration).proxyStatePost(accountId, applicationId, environmentName, proxyName, banExpression, async, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     * Get the proxy's configuration.
     * @param {number} accountId The account identifier number
     * @param {number} applicationId The application identifier number
     * @param {string} environmentName The name of the environment
     * @param {string} proxyName The proxy identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public configurationGet(accountId: number, applicationId: number, environmentName: string, proxyName: string, options?: any) {
        return ProxyApiFp(this.configuration).configurationGet(accountId, applicationId, environmentName, proxyName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set the proxy's configuration.
     * @param {ProxyConfiguration} body Proxy configuration update details
     * @param {number} accountId The account identifier number
     * @param {number} applicationId The application identifier number
     * @param {string} environmentName The name of the environment
     * @param {string} proxyName The proxy identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public configurationPost(body: ProxyConfiguration, accountId: number, applicationId: number, environmentName: string, proxyName: string, options?: any) {
        return ProxyApiFp(this.configuration).configurationPost(body, accountId, applicationId, environmentName, proxyName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patch the proxy with a JSON Patch. See - RFC6902 https://tools.ietf.org/html/rfc6902 - http://jsonpatch.com/
     * @param {Array&lt;RFC6902Operation&gt;} body 
     * @param {string} filepath the path to the file you want to modify. Case-sensitive.
     * @param {number} accountId The account identifier number
     * @param {number} applicationId The application identifier number
     * @param {string} environmentName The name of the environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public patchFile(body: Array<RFC6902Operation>, filepath: string, accountId: number, applicationId: number, environmentName: string, options?: any) {
        return ProxyApiFp(this.configuration).patchFile(body, filepath, accountId, applicationId, environmentName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send a message to a specified proxy
     * @param {number} accountId The account identifier number
     * @param {number} applicationId The application identifier number
     * @param {string} environmentName The name of the environment
     * @param {string} proxyName The proxy identifier
     * @param {string} operationName 
     * @param {string} [operationParameter] Parmeter to send with the message to a proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public proxyOperationAction(accountId: number, applicationId: number, environmentName: string, proxyName: string, operationName: string, operationParameter?: string, options?: any) {
        return ProxyApiFp(this.configuration).proxyOperationAction(accountId, applicationId, environmentName, proxyName, operationName, operationParameter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Applies a varnish ban expression to the specified proxy
     * @param {number} accountId The account identifier number
     * @param {number} applicationId The application identifier number
     * @param {string} environmentName The name of the environment
     * @param {string} proxyName The proxy identifier
     * @param {string} [banExpression] The varnish ban expression to apply
     * @param {boolean} [async] If true the call will return immediately, not waiting for all delivery nodes to complete the ban
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public proxyStatePost(accountId: number, applicationId: number, environmentName: string, proxyName: string, banExpression?: string, async?: boolean, options?: any) {
        return ProxyApiFp(this.configuration).proxyStatePost(accountId, applicationId, environmentName, proxyName, banExpression, async, options).then((request) => request(this.axios, this.basePath));
    }
}
